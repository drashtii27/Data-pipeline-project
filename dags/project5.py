# -*- coding: utf-8 -*-
"""PROJECT5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HAk12z_vvBGw2gRJZ3sJgv6P9LheUSLM
"""

from airflow import DAG
from airflow.decorators import task
from airflow.providers.snowflake.hooks.snowflake import SnowflakeHook
from datetime import datetime, timedelta
import requests
import logging
import pandas as pd

# Default DAG arguments
default_args = {
    'owner': 'Lab2',
    'start_date': datetime(2024, 11, 13),
    'retries': 0,
    'retry_delay': timedelta(minutes=5),
}

API_KEY = "B8C48E62-BBEA-4A88-BF9C-66DCE61A1A20"
BASE_URL = "https://rest.coinapi.io/v1"

# DAG Definition
with DAG(
    dag_id='bitcoin_data_ETL',
    default_args=default_args,
    schedule_interval='@hourly',  # Fetches data hourly
    catchup=False,
) as dag:

    @task
    def create_tables():
        """Create historical and real-time data tables in Snowflake if they don't exist."""
        snowflake_hook = SnowflakeHook(snowflake_conn_id='snowflake_default')
        conn = snowflake_hook.get_conn()
        cur = conn.cursor()
        try:
            cur.execute("USE DATABASE lab2")
            cur.execute("USE SCHEMA raw_data")

            # Historical Data Table
            cur.execute("""
            CREATE TABLE IF NOT EXISTS raw_data.bitcoin_historical (
                time_period_start TIMESTAMP,
                time_period_end TIMESTAMP,
                time_open TIMESTAMP,
                time_close TIMESTAMP,
                price_open FLOAT,
                price_high FLOAT,
                price_low FLOAT,
                price_close FLOAT,
                volume_traded FLOAT,
                trades_count INT,
                timestamp TIMESTAMP_LTZ DEFAULT CURRENT_TIMESTAMP
            );
            """)

            # Real-Time Data Table
            cur.execute("""
            CREATE TABLE IF NOT EXISTS raw_data.bitcoin_realtime (
                time_period_start TIMESTAMP,
                time_period_end TIMESTAMP,
                time_open TIMESTAMP,
                time_close TIMESTAMP,
                price_open FLOAT,
                price_high FLOAT,
                price_low FLOAT,
                price_close FLOAT,
                volume_traded FLOAT,
                trades_count INT,
                timestamp TIMESTAMP_LTZ DEFAULT CURRENT_TIMESTAMP
            );
            """)

            logging.info("Tables created successfully.")
        except Exception as e:
            logging.error(f"Error creating tables: {e}")
            raise
        finally:
            cur.close()
            conn.close()

    @task
    def fetch_historical_data():
        """Fetch historical Bitcoin data."""
        url = f"{BASE_URL}/ohlcv/BITSTAMP_SPOT_BTC_USD/history"
        headers = {'X-CoinAPI-Key': API_KEY}
        params = {
            'period_id': '1DAY',
            'time_start': '2023-01-01T00:00:00.0000000Z',
            'time_end': datetime.now().strftime('%Y-%m-%dT%H:%M:%S'),
        }

        try:
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()
            data = response.json()

            df = pd.DataFrame(data)
            df = df.rename(columns={
                'time_period_start': 'time_period_start',
                'time_period_end': 'time_period_end',
                'time_open': 'time_open',
                'time_close': 'time_close',
                'price_open': 'price_open',
                'price_high': 'price_high',
                'price_low': 'price_low',
                'price_close': 'price_close',
                'volume_traded': 'volume_traded',
                'trades_count': 'trades_count'
            })
            logging.info(f"Fetched historical data: {df.head()}")
            return df.to_dict(orient='records')
        except Exception as e:
            logging.error(f"Error fetching historical data: {e}")
            raise

    @task
    def fetch_realtime_data():
        """Fetch real-time Bitcoin data with 1-minute granularity."""

        # Define the start and end times for the data request
        time_end = datetime.now().strftime('%Y-%m-%dT%H:%M:%S') + 'Z'
        time_start = (datetime.now() - timedelta(minutes=10)).strftime('%Y-%m-%dT%H:%M:%S') + 'Z'

        # Set the parameters for the API request
        url = f"{BASE_URL}/ohlcv/BITSTAMP_SPOT_BTC_USD/history"
        headers = {'X-CoinAPI-Key': API_KEY}
        params = {
            'period_id': '1MIN',  # 1-minute granularity
            'time_start': time_start,
            'time_end': time_end
        }

        try:
            # Make the request to CoinAPI
            response = requests.get(url, headers=headers, params=params)
            response.raise_for_status()  # Raise an error if the status code is not 200 (OK)

            # Parse the response JSON
            data = response.json()

            # Check if data exists
            if not data:
                logging.warning("No data returned for real-time fetch.")
                return []

            # Convert the data to a DataFrame (optional)
            df = pd.DataFrame(data)
            df = df.rename(columns={
                'time_period_start': 'time_period_start',
                'time_period_end': 'time_period_end',
                'time_open': 'time_open',
                'time_close': 'time_close',
                'price_open': 'price_open',
                'price_high': 'price_high',
                'price_low': 'price_low',
                'price_close': 'price_close',
                'volume_traded': 'volume_traded',
                'trades_count': 'trades_count'
            })

            logging.info(f"Fetched real-time data: {df.head()}")

            # Return the data as a list of records
            return df.to_dict(orient='records')

        except requests.exceptions.HTTPError as e:
            logging.error(f"HTTP Error while fetching real-time data: {e}")
            raise
        except Exception as e:
            logging.error(f"Error fetching real-time data: {e}")
            raise
    @task
    def insert_historical_data(historical_data):
        """Insert Bitcoin historical data into Snowflake."""
        if not historical_data:
            logging.error("No historical data to insert.")
            return

        snowflake_hook = SnowflakeHook(snowflake_conn_id='snowflake_default')
        conn = snowflake_hook.get_conn()
        cur = conn.cursor()

        try:
            insert_query = """
                INSERT INTO raw_data.bitcoin_historical (
                    time_period_start, time_period_end, time_open, time_close,
                    price_open, price_high, price_low, price_close,
                    volume_traded, trades_count
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            for record in historical_data:
                values = tuple(record.values())  # Automatically extracts the values
                cur.execute(insert_query, values)

            conn.commit()
            logging.info(f"Successfully inserted {len(historical_data)} records into bitcoin_historical.")
        except Exception as e:
            conn.rollback()
            logging.error(f"Error inserting historical data: {e}")
            raise
        finally:
            cur.close()
            conn.close()

    @task
    def insert_realtime_data(realtime_data):
        """Insert Bitcoin real-time data into Snowflake."""
        if not realtime_data:
            logging.error("No real-time data to insert.")
            return

        snowflake_hook = SnowflakeHook(snowflake_conn_id='snowflake_default')
        conn = snowflake_hook.get_conn()
        cur = conn.cursor()

        try:
            insert_query = """
                INSERT INTO raw_data.bitcoin_realtime (
                    time_period_start, time_period_end, time_open, time_close,
                    price_open, price_high, price_low, price_close,
                    volume_traded, trades_count
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            for record in realtime_data:
                values = tuple(record.values())  # Automatically extracts the values
                cur.execute(insert_query, values)

            conn.commit()
            logging.info(f"Successfully inserted {len(realtime_data)} records into bitcoin_realtime.")
        except Exception as e:
            conn.rollback()
            logging.error(f"Error inserting real-time data: {e}")
            raise
        finally:
            cur.close()
            conn.close()

    # Task dependencies
    create_tables_task = create_tables()
    historical_data = fetch_historical_data()
    realtime_data = fetch_realtime_data()

    create_tables_task >> [insert_historical_data(historical_data), insert_realtime_data(realtime_data)]